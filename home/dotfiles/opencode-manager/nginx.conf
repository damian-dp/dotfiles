events {
    worker_connections 1024;
}

http {
    # Disable strict header checking for upstream responses
    # This is the key to working around the Hono duplicate header bug
    lua_need_request_body off;
    
    upstream backend {
        server 127.0.0.1:5003;
    }

    server {
        listen 8080;

        # Regular requests
        location / {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto https;
            proxy_set_header Connection '';
            
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
        }

        # SSE endpoint - use cosocket to bypass nginx HTTP parsing
        location /api/sse/ {
            content_by_lua_block {
                local sock = ngx.socket.tcp()
                sock:settimeout(86400000) -- 24 hours in ms
                
                local ok, err = sock:connect("127.0.0.1", 5003)
                if not ok then
                    ngx.status = 502
                    ngx.say("Failed to connect: ", err)
                    return
                end
                
                -- Build the proxied request
                local req_headers = ngx.req.get_headers()
                local cookie = req_headers["cookie"] or ""
                local uri = ngx.var.uri
                local args = ngx.var.args or ""
                local full_uri = args ~= "" and (uri .. "?" .. args) or uri
                
                local request = "GET " .. full_uri .. " HTTP/1.1\r\n" ..
                    "Host: " .. (req_headers["host"] or "localhost") .. "\r\n" ..
                    "Accept: text/event-stream\r\n" ..
                    "Cookie: " .. cookie .. "\r\n" ..
                    "X-Real-IP: " .. ngx.var.remote_addr .. "\r\n" ..
                    "X-Forwarded-For: " .. (req_headers["x-forwarded-for"] or ngx.var.remote_addr) .. "\r\n" ..
                    "X-Forwarded-Proto: https\r\n" ..
                    "Connection: keep-alive\r\n\r\n"
                
                local bytes, err = sock:send(request)
                if not bytes then
                    ngx.status = 502
                    ngx.say("Failed to send request: ", err)
                    return
                end
                
                -- Read response line
                local line, err = sock:receive("*l")
                if not line then
                    ngx.status = 502
                    ngx.say("Failed to read response: ", err)
                    return
                end
                
                -- Parse status
                local status = tonumber(string.match(line, "HTTP/%d%.%d (%d+)"))
                if not status then
                    ngx.status = 502
                    ngx.say("Invalid response line: ", line)
                    return
                end
                
                ngx.status = status
                
                -- Read headers (skip duplicates)
                local seen_headers = {}
                while true do
                    line, err = sock:receive("*l")
                    if not line or line == "" then break end
                    
                    local name, value = string.match(line, "^([^:]+):%s*(.*)$")
                    if name then
                        local lower_name = string.lower(name)
                        -- Skip duplicate headers and connection-related headers
                        if not seen_headers[lower_name] and lower_name ~= "transfer-encoding" and lower_name ~= "connection" then
                            seen_headers[lower_name] = true
                            ngx.header[name] = value
                        end
                    end
                end
                
                -- Set SSE headers
                ngx.header["Content-Type"] = "text/event-stream"
                ngx.header["Cache-Control"] = "no-cache"
                ngx.header["Connection"] = "keep-alive"
                
                ngx.flush(true)
                
                -- Stream the body
                while true do
                    local data, err, partial = sock:receive(4096)
                    if data then
                        ngx.print(data)
                        ngx.flush(true)
                    elseif partial and #partial > 0 then
                        ngx.print(partial)
                        ngx.flush(true)
                    end
                    if err then
                        break
                    end
                end
                
                sock:close()
            }
        }
    }
}
